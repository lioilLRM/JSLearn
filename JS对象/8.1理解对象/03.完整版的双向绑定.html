<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>完整版本的双向绑定</title>
</head>
<body>
  <p>请输入:</p>
  <input type="text" id="input">
  <p id="p"></p>


  <script>
// 学习内容：
//  1. ES6 中的静态方法和普通方法有什么区别？有哪些例子？
//     静态方式是在class 定义类的时候通过关键字 static 来实现的静态方法。
//     静态方法的调用方式是只能通过类名来调用。实例调用会报错。
//     例子：Array.from()、Array.isArray()
// ES6中的静态方法：

  </script>
  <script>


const Vue = (function(){
  let uid  = 0
class Dep{
  static myStaticProp = 32;
  static target = null;
  static classMethod() {
    return '这是类的静态方法，实例无法调用！'
  }

  constructor() {
    this.id = uid++
    this.subs = []
  }
  addSub(sub) {
    this.subs.push(sub)
  }
  notify() {
    this.subs.forEach(sub => sub.update())
  }
  // 这个方法的作用是什么？没看明白
  depend() {
    Dep.target.addDep(this)
  }
}
// let dep = new Dep()

// console.log(`dep.getClassName()：`,Dep.name);
// console.log(`Dep.classMethod：`,Dep.classMethod());
// console.log(`dep.classMethod：`,dep.classMethod());
// console.log('静态属性：', Dep.myStaticProp);

class Observer{
  constructor(obj) {
    this.obj = obj;
    this.walk(obj)
  }
  walk(obj) {
    Object.keys(obj).forEach(key => this.convert(key, obj[key]))
  }

  convert(key, value) {
    defineReative(this.obj, key, value)
  }
}

function defineReative(obj, key, value) {
  let dep = new Dep()
  let childObserver = observe(value)

  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: true,
    get:()=> {
      if(Dep.target) dep.depend()
      return value
    },
    set:(newValue)=> {
      if(value === newValue)return
      value = newValue
      childObserver = observe(newValue)
      dep.notify()
    }
  })
}

function observe(value) {
  if(!value || typeof value !== 'object') return
  return new Observer(value)
}

class Watcher{
  constructor(vm, expOrFn, callback) {
    this.depIds = {}
    this.vm = vm
    this.callback = callback
    this.expOrFn = expOrFn
    this.val = this.get()
  }
  update(){
    this.run()
  }
  addDep(dep) {
    // 如果在depIds的hash中没有当前的id,可以判断是新Watcher,因此可以添加到dep的数组中储存
    // 此判断是避免同id的Watcher被多次储存
    if (!this.depIds.hasOwnProperty(dep.id)) {
      dep.addSub(this);
      this.depIds[dep.id] = dep;
    }
  }
  get() {
      // 当前订阅者(Watcher)读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者
      Dep.target = this;
      const val = this.vm._data[this.expOrFn];
      // 置空，用于下一个Watcher使用
      Dep.target = null;
      console.log(Dep.target, 2);
      return val;
    }
    run() {
      const val = this.get();
      console.log('run:', val);
      if (val !== this.val) {
        this.val = val;
        this.callback.call(this.vm, val);
      }
    }

}

class Vue {
  constructor(options = {}) {
    this.$options = options
    let data = (this._data = this.$options.data)
    Object.keys(data).forEach(key => this._proxy(key))
    observe(data)
  }
  $watch(expOrFn, cb) {

    new Watcher(this, expOrFn, cb)
  }
  _proxy(key) {
    Object.defineProperty(this, key, {
      configurable: true,
      enumerable: true,
      get:() => this._data[key],
      set: val => {
        console.log(`set val：`,key, val);
        
        this._data[key] = val
      }
    })
  }
}
return Vue
})();

let demo = new Vue({
  data: {
    text: '',
  },
});
console.log(`demo：`,demo);

const p = document.getElementById('p');
const input = document.getElementById('input');
console.log(`p：`,p);

input.addEventListener('keyup', function(e) {
  demo.text = e.target.value;
  console.log(`e.target.value：`,e.target.value);
  
});

demo.$watch('text', str => {
  console.log(`str：`,str);
  
  p.innerHTML = str
});



  </script>
</body>
</html>