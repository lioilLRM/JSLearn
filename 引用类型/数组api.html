<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<script type="text/javascript">
      ;(function(){
        var arr = [1,2,3,4,5];
			for(var i in arr) {
					// console.log(arr[i]);
			}
			var result = arr.every(function(item, index) {
				console.log(item);
				if(item>3) {
					return true
				}
			})
			console.log(result);
			
			var arr2 = [1,2,4,52,14];
			var arrSortResult = arr2.sort(function(a,b){
				// 从小到大排序
				// return a-b
				// 从大到小排序
				return b-a
			})
			console.log(arrSortResult);
			
			var filterArr = arr2.filter(function(item,index){
				if(item>2) {
					return true
				}
			})
			console.log(filterArr);
      }())

      ;(function(){
        console.warn('=======数组的三种声明方式=======')
        console.log(`：`,);
        let arr = [1,2,3]
        let arrType2 = new Array(1,2,3)
        let arrType3 = Array(1,2,3)
        console.log(`arr, arrType2, arrType3：`,arr, arrType2, arrType3);
        
        console.warn('=======数组的原型都是Array.prototype=======')
        console.log(`arr.__proto__：`,arr.__proto__);
        console.log(`arrType2.__proto__：`,arrType2.__proto__);
        console.log(`arrType3.__proto__：`,arrType3.__proto__);
        console.log(`Array.prototype：`,Array.prototype);
        
        console.warn('=======证明数组是模仿对象而来的=======')
        let obj = {
          0: 1,  1: 2, 2: 3
        }
        // obj.name ==> 转换为obj[name]
        console.log(`arr[0], obj[0]：`,arr[0], obj[0]);
        
        console.warn('=======稀松数组，最后一个逗号不认=======')
        var emptyArr = [,,]
        console.log(`emptyArr：`,emptyArr);
        var arr2 = [,1,2,3,]
        console.log(`最后一个逗号不认：arr2.length`,arr2.length);
        
        console.warn('=======new Array()不同参数的结果=======')
        let oneNumberArr = new Array(5)
        console.log(`设置长度：oneNumberArr：`,oneNumberArr);
        let strArr = new Array('12')
        console.log(`strArr：`,strArr);
        let poorArr = new Array(1,2,)
        console.log(`poorArr：`,poorArr);
        
        console.warn('=======访问数组不存在的下标结果=======')
        console.log(`arr2[4]：`,arr2[4]);
        
        console.warn('=======数组的方法从哪来的？从Array.prototype继承来的=======')
        
        console.warn('=======数组push,unshift的返回值是什么？=======')
        var pushArr = [1,2,3]
        console.log(`执行了方法以后数组的长度：pushArr.push(11)：`,pushArr.push(11));
        console.log(`pushArr.unshift(00)：`,pushArr.unshift(0,9,20), pushArr);
        
        console.warn('=======自定义数组的push,pop方法=======')
        Array.prototype.myPush = function() {
          for(let i  = 0;i< arguments.length;i++) {
            this[this.length] = arguments[i];
          }
          return this.length
        }
       console.log(` pushArr.myPush(3,22,22)：`, pushArr.myPush(3,22,23), pushArr);
      // console.log(`pushArr.pop(),pushArr：`,pushArr.pop(),pushArr);
      
       Array.prototype.myPop = function() {
          let res = this[this.length-1];
          this.length--
          return res
       }
      console.log(`pushArr.myPop(), pushArr：`,pushArr.myPop(), pushArr);
      
       console.warn('=======实现数组的unshift,shift方法=======')
       let unshiftArr = [1,2,3]
       Array.prototype.myUnshift = function() {
        let len = this.length
        for(let i = 0;i< arguments.length;i++) {
          this[i+len] = this[i];
          this[i] = arguments[i];
        }
        return this.length
       }

       Array.prototype.myShift = function() {
         let res = this[0]
          for(let i = 0;i< this.length;i++) {
            this[i] = this[i+1]
          }
          this.length--
         return res
       }

       console.log(`pushArr.myUnshift(11,22,33), pushArr：`,
       unshiftArr.myUnshift(11,22,33,99,11), unshiftArr);
       console.log(`unshiftArr.myShift(), unshiftArr：`,unshiftArr.myShift(), unshiftArr);
       
       console.warn('=======数组reverse方法=======')
       let reverseArr = [12,3,4]
       console.log(`reverseArr.reverse()：`,reverseArr.reverse());
       
       console.warn('=======数组的splice=======')
       let spliceArr = [1,2,4]
       spliceArr.splice(2, 0 , 3)
       console.log(`从前插入：`, spliceArr);
       spliceArr.splice(-2, 0, '后面插入')
       console.log(`后面插入:spliceArr：`,spliceArr);
       
       console.warn('=======数组sort方法：是按照ascii码排序的=======')
       var sortArr = ['b', 'z', 'h', 'ii', 'a']
       sortArr.sort()
       console.log(`sortArr：`,sortArr);
       console.log(`排序方法返回的结果：sortArr.sort()：`,sortArr.sort());
        
       let sortArr2 = [23, 46, 5, 7]
       console.log(`sortArr2.sort()：`,sortArr2.sort());
       // sort内部自定义的函数要求a,b两个参数比较：
       // 返回值：1. 正值，b排在前面，2，负值，a安排在前面 3. 0,保持不动。
       // 公司里面最重要的是什么：代码的可读性，而不是简写。
       sortArr2.sort(function(a, b) {
        //  if(a>b) {
        //    return 1
        //  } else {
        //    return -1
        //  }
        return a-b
       })
       console.log(`sortArr2：`,sortArr2);

       ;(function(){
         console.warn('=======数组的随机排序=======')
          let arr = [1,2,3,4,5,6,7]

          arr.sort(function() {
            // var rand = Math.random()
            // if(rand - 0.5 >0){
            //   return 1
            // } else {
            //   return -1
            // }
            return Math.random() - 0.5
          })
          console.log(`arr：`,arr);
          console.warn('=======数组对象排序=======')
          let students = [
            {name: 'Jenny', age: 12},
            {name: 'Benny', age: 21},
            {name: 'Renny', age: 13},
            {name: 'Penny', age: 14},
          ]
          students.sort(function(a, b){
            return a.age - b.age;
          })
          console.log(`students：`,students);
          

          
       }())



      }())

      // 2022年2月27日 P16 小野前端 JavaScript深度指南
			;(function(){
        console.warn('=======concat()=======')
        console.warn('=======toString()=======')
        ;(function(){
         console.warn('=======slice：克隆一个数组=======')
          let arr = [1,2,3,{name: 'John', age:12}, 5, 6]
          let arr2 = arr.slice()
          arr[3].name = 'new Date'
          console.log(`arr2, arr：`,arr2, arr);
          
          // slice方法参数：[start, end)，第一个参数为闭区间；第二个参数为开区间
          let arr3 = arr.slice(1, 4)
          console.log(`arr3：`,arr3);
          let arr4 = arr.slice(-3,-1)
          console.log(`arr4：`,arr4);
          
          
          console.warn('=======数组join方法和参数=======')
          console.log(`arr.join()：`,arr.join());
          console.log(`arr.join('-')：`,arr.join('-'));

          console.warn('=======数组split方法和参数=======')
        }())        
      }())

      ;(function(){
        console.warn('=======类数组=======')
        function test() {
          // 不能使用push方法，
          // 没有继承自Array.prototype
          console.log(`arguments：`,arguments);
        }
        test(12,3,4,5)
        console.log('类数组的面试题');
        
        var obj = {
          '2': 3,
          '3': 4,
          'length': 2,
          'splice': Array.prototype.splice,
          'push': Array.prototype.push
        }
        obj.push(1)
        obj.push(2)
        console.log(`obj：`,obj);
        // 原理：
        // Array.prototype.push = function(elem) {
        //   this[this.length] = elem
        //   this.length++
        // }
        console.warn('=======类数组对象转为数组=======')
        var obj2 = { '0': 1, 'length': 1,'splice': Array.prototype.splice,}
        console.log(`obj2：`,obj2);
        
        console.warn('=======类数组对象转换为数组同时拥有对象和数组的方法=======')
        let person = {
          '0': 'Person1',
          '1': '烹饪son',
          '2': '李斯',
          'length': 3,
          name: '张三',
          age: 12,
          splice: Array.prototype.splice,
          push: Array.prototype.push
        }
        // Object.prototype.splice = Array.prototype.splice
        // Object.prototype.push = Array.prototype.push

        person.push('老渣')
        console.log(`person：`,person);
        
      }())

      ;(function(){
        console.warn('=======作业：数组去重方式：数组转对象再取对象值返回=======')
        let arr = [22,22,44,11,1,2,3,1,2,3,4,'a', 'a','b','body']
        Array.prototype.unique = function(arr) {
          let obj = {}
          let res = []

          // 老师的写法
          // for(let i = 0; i< this.length; i++) {
          //   if(!obj.hasOwnProperty(this[i])) {
          //     obj[this[i]] = this[i]
          //     res.push(this[i])
          //   }
          // }


          // 我的写法
          // for(let i = 0;i< arguments[0].length;i++) {
          //   let value = arguments[0][i]
          //   obj[value] = value
          // }
          // for(let key in obj) {
          //   res.push(obj[key])
          // }
          return res
        }
        console.log(`arr.unique(arr)：`,arr.unique(arr));
        
        console.warn('=======封装typeof方法=======')

        function myTypeof(value) {
          // if(value === null) return null;
            // if(value === undefined) return undefined

            // if(typeof value === 'boolean') return 'boolean'
            // if(typeof value === 'number') return 'number'
            // if(typeof value === 'string') return 'string'
            // if(typeof value === 'function') return 'function'
            // let type;
            // if(typeof value === 'object') {
            //   let toString = Object.prototype.toString
            //   // console.log(`toString.call(value)：`,toString.call(value));
            //   type = toString.call(value)
            // }
            // return type
            let type = typeof value
            let resMap = {
              '[object Array]': 'object-array',
              '[object Object]': 'object-object',
              '[object Boolean]': 'object-boolean',
              '[object Number]': 'object-number',
              '[object String]': 'object-string',
            }
            if(value === null) return 'null'
            if(type === 'object') {
              let toString = Object.prototype.toString
              let key = toString.call(value)
              return resMap[key]
            } else {
              return type
            }

        }
        let testTypeofData = [undefined, null, false, 1, 'str', [12], {a: 1}, function a(){}, new Number(1), Boolean(false), new Boolean()]
        // testTypeofData.forEach(item => {
        //   console.log(`myTypeof(value)：`,myTypeof(value));
          
        // })
        console.log(`testTypeofData`,testTypeofData);
        for(let i = 0; i < testTypeofData.length; i++) {
          console.log(`i：`,myTypeof(testTypeofData[i]));
        }
      }())

      ;(function(){
        console.warn('=======面试题：计算单词出现的次数=======')
        let str = 'aetjlsdfc,dfdsf12dddd'

        function countWord(str) {
          let temp = {}
          for(let i = 0;i< str.length;i++) {
            if(temp.hasOwnProperty(str[i])) {
              temp[str[i]] ++
            } else {
              temp[str[i]] = 1
            }
          }
          return temp
        }
        console.log(`countWord(str)：`,countWord(str));
        
        console.warn('=======面试题：闭包=======')
        function closureFn() {
          var d = 0
          function inner() {
            d++
            console.log(`d：`,d);
            
          }

          this.f = inner
        }

        let close = new closureFn()
        close.f()
        close.f()
        // #易错点：本来我以为输出的是1，2，3,但是输出的1，2，1；两个实例里面的d处于不同的对象中
        let close2 = new closureFn()
        close2.f()

        console.warn('=======面试题：函数表达式在外部忽略函数名称，但是内部可以使用=======')
        var fnExpression = function fnName() {
          console.log(`innerHtml：`);
          fnName()
        }
        console.log(`fnExpression.name：`,fnExpression.name);
        
        console.log(`typeof(fnName)：`,typeof(fnName));
        

      console.warn('=======面试题：数组的特性，空值=======')
      function getWeekDay(day) {
        let daysOfWeek = [, '星期一', '星期二', '星期三', '星期4', '星期5', '星期6', '星期7']
        return daysOfWeek[day]!==undefined ? daysOfWeek[day]: '未知数'
      }
      console.log(`getWeekDay(3)：`,getWeekDay(3));
      

      }())
			
		</script>
	</body>
</html>
