<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>闭包</title>
</head>
<body>
  闭包：
  1. 作用：数据缓存
  <script type="text/javascript">
    // 2022年2月12日：小野前端 JavaScript深度指南
    // 当内部函数被返回到外部并保存时，一定会产生闭包
// 闭包会产生原来的作用域链不释放
// 过渡的闭包可能会导致内存泄漏，或加载过慢。
     function test1() {
      function test2() {
        var b = 2
        a = 21
        console.log(`b：a`,b, a);
      }
      var a = 1
      return test2;
   }
   var c = 3
   var test3 = test1();
  //  test3()

//闭包： 如何返回内部的多个函数，不用对象的情况下？
;(function() {
  return
  function returnTwoFn() {
     var n = 100
     function add() {
       n++
       console.log(`n：`,n);
     }
     function reduce() {
       n--
       console.log(`n：`,n);
     }

     return [add, reduce]
   }

   var arrFn = returnTwoFn()
   arrFn[0]()
   arrFn[1]()
})()

;(function() {

  //理解闭包: 面包管理
  function breadManage(num) {
    let breadNum  = arguments[0] || 10

    // function supply() {
    //   breadNum += 10
    //   console.log(`supply breadNum：`,breadNum);
    // }

    // function sale() {
    //   breadNum --
    //   console.log(`sale breadNum：`,breadNum);
    // }
    // return {supply, sale}

    let operation = {
      supply: ()=> {
          breadNum += 10
      console.log(`2supply breadNum：`,breadNum);
      },
      sale: ()=> {
        breadNum --
        console.log(`2sale breadNum：`,breadNum);
      }
    }
    return operation
  }

  let breadMg = breadManage()
  breadMg.supply()
  breadMg.sale()
})();

// 闭包面试题
(function() {
  console.log(`----闭包面试题----：\n`,);
  
  function closureFn() {
   var arr = []
  // let i = 0
    // 使用let i = 0, 形成了局部的作用域
  for(let  i = 0 ;i< 10; i++) {
    arr[i] = function() {
      console.log(`closureFn i：`,i);
    }
  }
  return arr
}
var myArrFn = closureFn()
myArrFn && myArrFn.forEach(fn => {
  // console.log(fn);
  fn()
})

// 立即执行函数的方式
function IIFEClosureFn2() {
  for(var i = 0;i< 10;i++) {
    (function(){console.log(`IIFEClosureFn2 i：`,i);}())
  }
}
IIFEClosureFn2()

// 立即执行函数：使用内部参数的方式；最常用的方式；
function IIFEInnerArgs() {
  var arr = []
  for(var  i = 0 ;i< 10; i++) {
    (function(j) {
      arr[j] = function() {
        console.log(`IIFEInnerArgs j：`, j);
      }
    }(i))
  }
  return arr
}
 let arrInnerArgs =  IIFEInnerArgs()
 arrInnerArgs && arrInnerArgs.forEach(fn => {
   fn()
 })

// 立即执行函数：外部传参的方式
function closureFnOutArgs() {
  let arr = []
  for(var  i = 0 ;i< 10; i++) {
    arr[i] = (function(num){
      console.log(`num：`,num);
    })
  }
  return arr
}
let arrOutArgs = closureFnOutArgs()
arrOutArgs && arrOutArgs.forEach((fn, index) => {
  fn(index)
})

console.log(`----闭包面试题----：\n`,);

}())
// 说明：将闭包挂载到window上
;(function(){
  console.log('将函数挂载到闭包上');
  
  function test() {
    var a = 1;

    function add() {
      a++
      console.log(`a：`,a);
    }
    window.add = add;
  }
  test()
  add()
  add()
  add()

}())

// 说明：ES5的插件写法
;(function(){
  function Plugin() {
    console.log(`init Plugin：`);
  } 
  window.Plugin = Plugin;
}())

var plugin = new Plugin();

// 说明：立即执行函数；对象原型挂载公共方法；window挂载函数写计算函数插件
;(function(){
  function Compute() {

  }
  Compute.prototype = {
    add: function() {
      return arguments[0] + arguments[1];
    },
    sub: function() {
      return arguments[0] - arguments[1];
    }
  }
  window.Compute = Compute;
}())

  var compute = new Compute()
  console.log(`compute.add(1,2)：`,compute.add(1,2));
  console.log(`compute.sub(1,2)：`,compute.sub(4,2));

  //2022年2月16日 P12 小野前端 JavaScript深度指南
  // 说明：闭包实现私有变量
  ;(function(){
    console.log('说明：闭包实现私有变量');
    
    function privateVariable() {
      let num = 0
      let compute = {
        add: function() {
          num++
          console.log(`num：`,num);
        },
        minus: function(){
          num--
          console.log(`num：`,num);
          
        }
      }
      return compute
    }

    let compute = privateVariable()
    compute.add()
    compute.add()
    compute.add()
    compute.minus()

  }())
// 构造函数创建闭包
  ;(function(){
    console.warn('构造函数创建闭包');
    
    function Compute() {
      let num = 10
      this.add = function() {
        num++
        console.log(`num：`,num);
        
      }
      this.minus = function() {
        num--
        console.log(num);
      }
      // 闭包是如何形成的：构造函数隐式返回return this
      // 其他说明：如果return 原始值不会影响结果；返回引用值影响
    }

    let compute = new Compute()
    compute.add()
    compute.add()
    compute.add()
  }())
  
  
  </script>
  
</body>
</html>